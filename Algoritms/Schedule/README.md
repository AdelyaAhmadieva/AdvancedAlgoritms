Алгоритм 𝑂 ( n 2 ) O(n 2 ): 
Для каждого предмета проверяем все доступные дни от последнего возможного к первому. 
Если день найден, помечаем его как занятый. 
Если день не найден, добавляем штраф за этот предмет. 
Временная сложность: 𝑂 ( n 2 ) O(n 2 ) из-за вложенного перебора предметов и дней. 


Алгоритм 𝑂 ( n log ⁡ 𝑛 ) O(nlogn):
Используем SortedSet для отслеживания доступных дней. 
Для каждого предмета ищем ближайший доступный день с использованием GetViewBetween ( 𝑂 ( log ⁡n ) O(logn)). 
Если день найден, удаляем его из множества. Если нет, добавляем штраф. 
Временная сложность: 𝑂 ( n log ⁡ 𝑛 ) O(nlogn) за сортировку предметов и эффективный поиск доступных дней.